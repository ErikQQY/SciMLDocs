<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty Quantified Deep Bayesian Model Discovery · Overview of Julia&#39;s SciML</title><meta name="title" content="Uncertainty Quantified Deep Bayesian Model Discovery · Overview of Julia&#39;s SciML"/><meta property="og:title" content="Uncertainty Quantified Deep Bayesian Model Discovery · Overview of Julia&#39;s SciML"/><meta property="twitter:title" content="Uncertainty Quantified Deep Bayesian Model Discovery · Overview of Julia&#39;s SciML"/><meta name="description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="twitter:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:url" content="https://docs.sciml.ai/stable/showcase/bayesian_neural_ode/"/><meta property="twitter:url" content="https://docs.sciml.ai/stable/showcase/bayesian_neural_ode/"/><link rel="canonical" href="https://docs.sciml.ai/stable/showcase/bayesian_neural_ode/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../../getting_started/first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../../getting_started/first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../../getting_started/fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../../getting_started/find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li class="is-active"><a class="tocitem" href>Uncertainty Quantified Deep Bayesian Model Discovery</a><ul class="internal"><li><a class="tocitem" href="#Step-1:-Import-Libraries"><span>Step 1: Import Libraries</span></a></li><li><a class="tocitem" href="#Setup:-Get-the-data-from-the-Spiral-ODE-example"><span>Setup: Get the data from the Spiral ODE example</span></a></li><li><a class="tocitem" href="#Step-2:-Define-the-Neural-ODE-architecture."><span>Step 2: Define the Neural ODE architecture.</span></a></li><li><a class="tocitem" href="#Step-3:-Define-the-loss-function-for-the-Neural-ODE."><span>Step 3: Define the loss function for the Neural ODE.</span></a></li><li><a class="tocitem" href="#Step-4:-Now-we-start-integrating-the-Bayesian-estimation-workflow-as-prescribed-by-the-AdvancedHMC-interface-with-the-NeuralODE-defined-above"><span>Step 4: Now we start integrating the Bayesian estimation workflow as prescribed by the AdvancedHMC interface with the NeuralODE defined above</span></a></li><li><a class="tocitem" href="#Step-5:-Plot-diagnostics"><span>Step 5: Plot diagnostics</span></a></li></ul></li><li><a class="tocitem" href="../blackhole/">Discovering the Relativistic Corrections to Binary Black Hole Dynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../pinngpu/">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li><li><a class="tocitem" href="../massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li><a class="tocitem" href="../symbolic_analysis/">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li><li><a class="tocitem" href="../optimization_under_uncertainty/">Optimization Under Uncertainty</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Showcase of Cool Examples</a></li><li><a class="is-disabled">Automated Model Discovery</a></li><li class="is-active"><a href>Uncertainty Quantified Deep Bayesian Model Discovery</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Uncertainty Quantified Deep Bayesian Model Discovery</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/showcase/bayesian_neural_ode.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="bnode"><a class="docs-heading-anchor" href="#bnode">Uncertainty Quantified Deep Bayesian Model Discovery</a><a id="bnode-1"></a><a class="docs-heading-anchor-permalink" href="#bnode" title="Permalink"></a></h1><p>In this tutorial, we show how SciML can combine the differential equation solvers seamlessly with Bayesian estimation libraries like AdvancedHMC.jl and Turing.jl. This enables converting Neural ODEs to Bayesian Neural ODEs, which enables us to estimate the error in the Neural ODE estimation and forecasting. In this tutorial, a working example of the Bayesian Neural ODE: NUTS sampler is shown.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For more details, have a look at this paper: https://arxiv.org/abs/2012.07244</p></div></div><h2 id="Step-1:-Import-Libraries"><a class="docs-heading-anchor" href="#Step-1:-Import-Libraries">Step 1: Import Libraries</a><a id="Step-1:-Import-Libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Import-Libraries" title="Permalink"></a></h2><p>For this example, we will need the following libraries:</p><pre><code class="language-julia hljs"># SciML Libraries
using SciMLSensitivity, DifferentialEquations

# ML Tools
using Lux, Zygote

# External Tools
using Random, Plots, AdvancedHMC, MCMCChains, StatsPlots, ComponentArrays</code></pre><h2 id="Setup:-Get-the-data-from-the-Spiral-ODE-example"><a class="docs-heading-anchor" href="#Setup:-Get-the-data-from-the-Spiral-ODE-example">Setup: Get the data from the Spiral ODE example</a><a id="Setup:-Get-the-data-from-the-Spiral-ODE-example-1"></a><a class="docs-heading-anchor-permalink" href="#Setup:-Get-the-data-from-the-Spiral-ODE-example" title="Permalink"></a></h2><p>We will also need data to fit against. As a demonstration, we will generate our data using a simple cubic ODE <code>u&#39; = A*u^3</code> as follows:</p><pre><code class="language-julia hljs">u0 = [2.0; 0.0]
datasize = 40
tspan = (0.0, 1)
tsteps = range(tspan[1], tspan[2], length = datasize)
function trueODEfunc(du, u, p, t)
    true_A = [-0.1 2.0; -2.0 -0.1]
    du .= ((u .^ 3)&#39;true_A)&#39;
end
prob_trueode = ODEProblem(trueODEfunc, u0, tspan)
ode_data = Array(solve(prob_trueode, Tsit5(), saveat = tsteps))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×40 Matrix{Float64}:
 2.0  1.97895   1.94728  1.87998  1.74775  …   0.353996   0.53937   0.718119
 0.0  0.403905  0.79233  1.15176  1.45561     -1.54217   -1.52816  -1.50614</code></pre><p>We will want to train a neural network to capture the dynamics that fit <code>ode_data</code>.</p><h2 id="Step-2:-Define-the-Neural-ODE-architecture."><a class="docs-heading-anchor" href="#Step-2:-Define-the-Neural-ODE-architecture.">Step 2: Define the Neural ODE architecture.</a><a id="Step-2:-Define-the-Neural-ODE-architecture.-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-the-Neural-ODE-architecture." title="Permalink"></a></h2><p>Note that this step potentially offers a lot of flexibility in the number of layers/ number of units in each layer. It may not necessarily be true that a 100 units architecture is better at prediction/forecasting than a 50 unit architecture. On the other hand, a complicated architecture can take a huge computational time without increasing performance.</p><pre><code class="language-julia hljs">dudt2 = Lux.Chain(x -&gt; x .^ 3,
                   Lux.Dense(2, 50, tanh),
                   Lux.Dense(50, 2))

rng = Random.default_rng()
p, st = Lux.setup(rng, dudt2)
const _st = st
function neuralodefunc(u, p, t)
    dudt2(u, p, _st)[1]
end
function prob_neuralode(u0, p)
    prob = ODEProblem(neuralodefunc, u0, tspan, p)
    sol = solve(prob, Tsit5(), saveat = tsteps)
end
p = ComponentArray{Float64}(p)
const _p = p</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(layer_1 = Float64[], layer_2 = (weight = [-0.05503370612859726 0.3314313292503357; -0.04280583932995796 0.25783979892730713; … ; 0.2596352696418762 0.3367233872413635; -0.2136920839548111 -0.19713203608989716], bias = [0.0; 0.0; … ; 0.0; 0.0;;]), layer_3 = (weight = [0.11807635426521301 0.24092590808868408 … -0.14730402827262878 -0.27961915731430054; -0.14735424518585205 0.28157463669776917 … -0.283164918422699 -0.22003759443759918], bias = [0.0; 0.0;;]))</code></pre><p>Note that the <code>f64</code> is required to put the Lux neural network into Float64 precision.</p><h2 id="Step-3:-Define-the-loss-function-for-the-Neural-ODE."><a class="docs-heading-anchor" href="#Step-3:-Define-the-loss-function-for-the-Neural-ODE.">Step 3: Define the loss function for the Neural ODE.</a><a id="Step-3:-Define-the-loss-function-for-the-Neural-ODE.-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Define-the-loss-function-for-the-Neural-ODE." title="Permalink"></a></h2><pre><code class="language-julia hljs">function predict_neuralode(p)
    p = p isa ComponentArray ? p : convert(typeof(_p),p)
    Array(prob_neuralode(u0, p))
end
function loss_neuralode(p)
    pred = predict_neuralode(p)
    loss = sum(abs2, ode_data .- pred)
    return loss, pred
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">loss_neuralode (generic function with 1 method)</code></pre><h2 id="Step-4:-Now-we-start-integrating-the-Bayesian-estimation-workflow-as-prescribed-by-the-AdvancedHMC-interface-with-the-NeuralODE-defined-above"><a class="docs-heading-anchor" href="#Step-4:-Now-we-start-integrating-the-Bayesian-estimation-workflow-as-prescribed-by-the-AdvancedHMC-interface-with-the-NeuralODE-defined-above">Step 4: Now we start integrating the Bayesian estimation workflow as prescribed by the AdvancedHMC interface with the NeuralODE defined above</a><a id="Step-4:-Now-we-start-integrating-the-Bayesian-estimation-workflow-as-prescribed-by-the-AdvancedHMC-interface-with-the-NeuralODE-defined-above-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Now-we-start-integrating-the-Bayesian-estimation-workflow-as-prescribed-by-the-AdvancedHMC-interface-with-the-NeuralODE-defined-above" title="Permalink"></a></h2><p>The AdvancedHMC interface requires us to specify: (a) the Hamiltonian log density and its gradient , (b) the sampler and (c) the step size adaptor function.</p><p>For the Hamiltonian log density, we use the loss function. The θ*θ term denotes the use of Gaussian priors.</p><p>The user can make several modifications to Step 4. The user can try different acceptance ratios, warmup samples and posterior samples. One can also use the Variational Inference (ADVI) framework, which doesn&#39;t work quite as well as NUTS. The SGLD (Stochastic Gradient Langevin Descent) sampler is seen to have a better performance than NUTS. Have a look at https://sebastiancallh.github.io/post/langevin/ for a brief introduction to SGLD.</p><pre><code class="language-julia hljs">l(θ) = -sum(abs2, ode_data .- predict_neuralode(θ)) - sum(θ .* θ)
function dldθ(θ)
    x, lambda = Zygote.pullback(l, θ)
    grad = first(lambda(1))
    return x, grad
end

metric = DiagEuclideanMetric(length(p))
h = Hamiltonian(metric, l, dldθ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Hamiltonian(metric=DiagEuclideanMetric([1.0, 1.0, 1.0, 1.0, 1.0, 1 ...]), kinetic=AdvancedHMC.GaussianKinetic())</code></pre><p>We use the NUTS sampler with an acceptance ratio of δ= 0.45 in this example. In addition, we use Nesterov Dual Averaging for the Step Size adaptation.</p><p>We sample using 500 warmup samples and 500 posterior samples.</p><pre><code class="language-julia hljs">integrator = Leapfrog(find_good_stepsize(h, p))
kernel = HMCKernel(Trajectory{MultinomialTS}(integrator, GeneralisedNoUTurn()))
adaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(0.45, integrator))
samples, stats = sample(h, kernel, p, 500, adaptor, 500; progress = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(ComponentArrays.ComponentVector{Float64, Vector{Float64}, Tuple{ComponentArrays.Axis{(layer_1 = 1:0, layer_2 = ViewAxis(1:150, Axis(weight = ViewAxis(1:100, ShapedAxis((50, 2))), bias = ViewAxis(101:150, ShapedAxis((50, 1))))), layer_3 = ViewAxis(151:252, Axis(weight = ViewAxis(1:100, ShapedAxis((2, 50))), bias = ViewAxis(101:102, ShapedAxis((2, 1))))))}}}[(layer_1 = Float64[], layer_2 = (weight = [-0.1459384981303275 0.36058696345271246; -0.08531445078956282 0.23131932781931921; … ; 0.2241782915645434 0.25356074289607944; -0.2363437487936005 -0.20843646239615776], bias = [0.041073471623665724; 0.03136413281361307; … ; 0.003536047846725959; 0.04736053379837796;;]), layer_3 = (weight = [0.20510366665339436 0.35273029494225844 … -0.2817690403807308 -0.23923046042466287; -0.169949892314972 0.22253083423408376 … -0.2607040199647619 -0.3240693552661359], bias = [-0.005905985830950167; -0.0017132201386393403;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.1459384981303275 0.36058696345271246; -0.08531445078956282 0.23131932781931921; … ; 0.2241782915645434 0.25356074289607944; -0.2363437487936005 -0.20843646239615776], bias = [0.041073471623665724; 0.03136413281361307; … ; 0.003536047846725959; 0.04736053379837796;;]), layer_3 = (weight = [0.20510366665339436 0.35273029494225844 … -0.2817690403807308 -0.23923046042466287; -0.169949892314972 0.22253083423408376 … -0.2607040199647619 -0.3240693552661359], bias = [-0.005905985830950167; -0.0017132201386393403;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.08010538933513096 0.4197765847940471; -0.08941482296759959 0.005116081468193839; … ; 0.029605041929726017 0.01839334725140937; 0.028985130096363915 -0.407430511686179], bias = [0.041299684026948204; -0.40108521503164074; … ; 0.26845014786497634; 0.2796834702592733;;]), layer_3 = (weight = [0.26683075641219767 0.5085331669584894 … -0.17122645596249125 -0.36830370574545346; -0.1530579691837548 0.3594794614507397 … -0.294359584432062 -0.6107577221818961], bias = [-0.412475666769306; -0.1608092871952485;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.08067148998919245 0.412120492035021; -0.100800129306742 -0.07806700993580626; … ; 0.003766988125269849 0.023204367609571768; -0.009308743210673369 -0.25061028279844844], bias = [0.010853044107322154; -0.4572763336076902; … ; 0.24755988888070168; 0.23322951340974796;;]), layer_3 = (weight = [0.2608432451893338 0.5253309510809127 … -0.293441633473506 -0.33166166732667396; -0.031025029745443605 0.17907599434885738 … -0.19192354590192381 -0.5294087965959762], bias = [-0.3920710587536918; -0.20930531728446;;])), (layer_1 = Float64[], layer_2 = (weight = [0.1888402503727329 0.433115564473784; -0.027087883724573728 0.06168579837296417; … ; -0.02800795478041619 -0.1334019239830432; -0.11780037114357636 -0.256519054015519], bias = [-0.09954032772639275; -0.2912558754517697; … ; 0.178851040152106; 0.10059476457617697;;]), layer_3 = (weight = [0.30985010183139744 0.5733976520162789 … -0.42936854585533624 -0.22634659569231894; -0.2827479103677253 0.16005006342694947 … -0.02438499455783935 -0.7735856727645252], bias = [-0.5956769059584528; -0.3982154688244349;;])), (layer_1 = Float64[], layer_2 = (weight = [0.15242163228969288 0.6186450334438534; -0.2162137791536205 0.034908949960238946; … ; 0.011986378549802973 -0.31056496560850566; 0.06335799838206968 -0.12399148081030581], bias = [0.026646813499549005; -0.18659052157832973; … ; 0.2309445519686551; 0.1864526906858535;;]), layer_3 = (weight = [0.21194231658860388 0.8133403306003815 … -0.5034197490877167 -0.1462626592594545; -0.01729220782758184 -0.01028545384456421 … 0.35626667504296083 -0.8511840082425316], bias = [-0.6289227571059928; -0.5519138374495962;;])), (layer_1 = Float64[], layer_2 = (weight = [0.29056460762626724 0.6977768643664174; -0.22523064466142015 0.09532888148589472; … ; 0.24378193144894966 -0.2836369067792945; -0.0033476181088316626 -0.030196882589765807], bias = [-0.11629416595476066; -0.3080751354667588; … ; 0.3043944719260872; 0.19871190269172778;;]), layer_3 = (weight = [-0.06792241607384458 0.6784980885702281 … -0.45652473503024 -0.35572010544481036; -0.006698477009020234 0.045481937913161075 … 0.20658460081293029 -0.8165964538821293], bias = [-0.8432359903584505; -0.27787536949295655;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.028857783556339306 0.8071898684700409; -0.17798671067999872 -0.196873386668272; … ; 0.2055199275796504 0.2544074351401167; -0.3747987310704929 0.24307923429353098], bias = [-0.42704601990054813; 0.2562761354080121; … ; -0.11647423825972916; -0.4937067460231095;;]), layer_3 = (weight = [-0.2541896609888687 0.5869590273975465 … -0.012709843024536732 -0.508098046513053; -0.35286361714254855 0.0042976753902451495 … 0.23851585384047322 -0.4558404615460846], bias = [-0.22144995137936863; -0.14958967184885583;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.028857783556339306 0.8071898684700409; -0.17798671067999872 -0.196873386668272; … ; 0.2055199275796504 0.2544074351401167; -0.3747987310704929 0.24307923429353098], bias = [-0.42704601990054813; 0.2562761354080121; … ; -0.11647423825972916; -0.4937067460231095;;]), layer_3 = (weight = [-0.2541896609888687 0.5869590273975465 … -0.012709843024536732 -0.508098046513053; -0.35286361714254855 0.0042976753902451495 … 0.23851585384047322 -0.4558404615460846], bias = [-0.22144995137936863; -0.14958967184885583;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.893827937042148 0.27171076786784515; -0.40194035839851355 0.051138063080947115; … ; 0.816784907792127 1.2948659745345832; -0.5403102144364699 0.6806127869439368], bias = [-0.1684325462033156; 1.3572553775374447; … ; 0.07179126182440367; 0.7047497732980141;;]), layer_3 = (weight = [-0.1674575471711688 2.114448371885257 … 0.5948675254785617 -0.29564225380726994; 0.1730149604309347 -1.0025613216879674 … -0.5238617767247193 -1.0012670775809633], bias = [-0.777683497659094; 0.36606627943753933;;]))  …  (layer_1 = Float64[], layer_2 = (weight = [0.39030490626017983 0.9049253997587616; -0.09179007324613163 0.8972864087262673; … ; -0.6125823927235664 -0.908688742738265; -0.784852015469376 -0.478173348980964], bias = [-0.5216700552457313; 0.5361781479285602; … ; 1.5965153835945753; -0.7040574657607419;;]), layer_3 = (weight = [-1.372666888206739 -0.625756398939473 … 0.7308456864997002 0.35662650471995133; 0.7043422067868347 0.14611338465628115 … -0.7534825515185946 -0.2896611427998927], bias = [-0.7547351655913552; -0.14234082862755384;;])), (layer_1 = Float64[], layer_2 = (weight = [0.7524687594068885 -0.6131761265910604; 0.42517074897310514 -0.11658307149417577; … ; -0.2862366191155983 0.14840153481810434; -0.312925266052987 1.0751406602293199], bias = [-0.8649034268204298; -0.17588705042421046; … ; -0.8836320643709697; 1.1483298710748426;;]), layer_3 = (weight = [0.8063204171645957 0.20873964960430683 … 0.18828623125384275 0.22084880705019685; 0.02743163009693647 0.013211340717629418 … -0.16706942399282612 0.14394567522457688], bias = [-0.320096398650712; 0.21206411318816457;;])), (layer_1 = Float64[], layer_2 = (weight = [1.1819381975300378 0.17633918147357702; -0.23824334711896294 -0.03452233546902514; … ; -0.8321095760950215 -0.40859403166667746; -0.3881808924614897 0.07719020158975981], bias = [-0.8066071643196479; 0.42703423544089564; … ; -0.6137779338132412; -0.2031195208714136;;]), layer_3 = (weight = [0.31066925160118825 -0.0923578125594339 … 0.48413723148363064 -0.7009965310978684; -1.0382273517386384 0.15521942505962924 … -0.1741549097573312 -0.27868959110747904], bias = [-0.30647406322637283; 0.29571702971890784;;])), (layer_1 = Float64[], layer_2 = (weight = [1.3780818567665394 -0.08279708561191813; 0.6932183327312487 0.03669118001365722; … ; -1.0142083895827245 -0.7013200610345103; -0.29201406509305117 -0.23798035177280646], bias = [-0.8232563889986173; 0.5888244329845524; … ; -0.8895754322777419; 0.15448279992001257;;]), layer_3 = (weight = [0.06027837854314224 0.12840621628415647 … 0.010048962307093626 -0.11583348992494152; 0.3923949261502182 0.48000132948375507 … 0.5778670604193388 0.21456195716298385], bias = [-0.1824041838360082; 0.6975282352146953;;])), (layer_1 = Float64[], layer_2 = (weight = [1.3780818567665394 -0.08279708561191813; 0.6932183327312487 0.03669118001365722; … ; -1.0142083895827245 -0.7013200610345103; -0.29201406509305117 -0.23798035177280646], bias = [-0.8232563889986173; 0.5888244329845524; … ; -0.8895754322777419; 0.15448279992001257;;]), layer_3 = (weight = [0.06027837854314224 0.12840621628415647 … 0.010048962307093626 -0.11583348992494152; 0.3923949261502182 0.48000132948375507 … 0.5778670604193388 0.21456195716298385], bias = [-0.1824041838360082; 0.6975282352146953;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.41064750351660906 -0.5978821171431913; 0.10824855268097204 -0.3590747616450413; … ; 0.6234024978853767 -0.24434162127272763; 0.8727309781423699 -0.2879734275022648], bias = [0.8651538710659494; -0.2857500309988253; … ; -1.2090024225459788; 0.43627954150803705;;]), layer_3 = (weight = [0.1031277597266302 -0.26925645219578404 … 1.3527127733614162 0.6074362366504205; 1.1475654257311985 0.4844846580753434 … -0.5871736479937815 -0.060795620293461375], bias = [-0.9719330579164656; 0.23571093725549697;;])), (layer_1 = Float64[], layer_2 = (weight = [-0.8664630080129806 1.281467773041894; -0.515332746504475 -0.06471545882517209; … ; 0.4918629243112536 0.09603873350096007; 0.8470680050574521 -0.5836050038338864], bias = [0.053406916645439874; 0.12433238477328934; … ; 1.0850036523428168; 0.21457467985948941;;]), layer_3 = (weight = [0.20111678117961151 0.855303141216334 … -0.027750994658439943 -0.15835713012807318; -1.6858142684750381 -1.0340353686370714 … 0.6625841290964516 1.0471513586071446], bias = [0.3908980334027406; 0.06155885528018692;;])), (layer_1 = Float64[], layer_2 = (weight = [-1.041673100148013 -0.09685334449522029; 1.0404740760313413 -0.387884399992587; … ; 1.2422022881179633 -0.08993844502634192; 1.0414078268429168 0.8101691931894185], bias = [-0.21338810235335928; -0.9663416096518692; … ; 0.504492907581085; -1.780930029754748;;]), layer_3 = (weight = [-0.6983632584383813 0.01422528308380355 … -0.8270174082046109 0.6746478287391403; -1.0807536180589459 -0.22024536202872227 … -0.22748264912935967 0.05721384491817629], bias = [-0.049024173855167004; -0.5338107460720172;;])), (layer_1 = Float64[], layer_2 = (weight = [-1.227772634894897 0.183046700238646; 0.8263088642569716 -0.5538631650569673; … ; 1.2279116936852783 -0.13852753411200575; 1.1466665089201664 0.8891721940398982], bias = [0.030525471489846037; -1.1914833133923612; … ; 0.3748599982922191; -1.5460176903991447;;]), layer_3 = (weight = [-0.6471153310539912 0.13117092645527537 … -1.1391522666045972 0.6339856897136377; -1.2355897777774045 -0.3861785415370562 … -0.47972597226935143 -0.052695527712637955], bias = [0.11165925463243967; -0.4706278581507959;;])), (layer_1 = Float64[], layer_2 = (weight = [-1.3607299793438474 0.9536353071566755; 1.2297052004011686 0.7822213603697253; … ; 0.7477859094883007 0.05440060851856675; 0.37748821169149044 1.4490768614780296], bias = [0.12248183256398884; -1.513073329336786; … ; 0.29096176623873915; -0.9902928356276459;;]), layer_3 = (weight = [-0.5203646090101497 -0.14708560213753696 … -0.8977123940282834 0.5043500840292321; -0.7108905562396003 -0.5168608733244067 … 0.6728570099747607 0.9642322886664131], bias = [-0.0456247906617588; 0.6957842438165494;;]))], NamedTuple[(n_steps = 31, is_accept = true, acceptance_rate = 0.45161291200885123, log_density = -201.0151709126594, hamiltonian_energy = 403.26192713283956, hamiltonian_energy_error = -13.703964566862737, max_hamiltonian_energy_error = 130.37245533903274, tree_depth = 5, numerical_error = false, step_size = 0.05, nom_step_size = 0.05, is_adapt = true), (n_steps = 2, is_accept = true, acceptance_rate = 6.6033404015015806e-136, log_density = -201.0151709126594, hamiltonian_energy = 338.70057602640554, hamiltonian_energy_error = 0.0, max_hamiltonian_energy_error = 1.5758632367866216e7, tree_depth = 1, numerical_error = true, step_size = 0.5014684357353391, nom_step_size = 0.5014684357353391, is_adapt = true), (n_steps = 4, is_accept = true, acceptance_rate = 0.2500416568181625, log_density = -138.94633722433773, hamiltonian_energy = 320.1467423939421, hamiltonian_energy_error = -10.667793104767213, max_hamiltonian_energy_error = 22242.229791659527, tree_depth = 2, numerical_error = true, step_size = 0.17377295602161824, nom_step_size = 0.17377295602161824, is_adapt = true), (n_steps = 6, is_accept = true, acceptance_rate = 0.7033938911641645, log_density = -131.29169770429957, hamiltonian_energy = 246.03710819696934, hamiltonian_energy_error = -1.650132288811477, max_hamiltonian_energy_error = 1924.7599490313241, tree_depth = 2, numerical_error = true, step_size = 0.08885147982099728, nom_step_size = 0.08885147982099728, is_adapt = true), (n_steps = 5, is_accept = true, acceptance_rate = 0.200536745985556, log_density = -107.95938025265383, hamiltonian_energy = 249.8162575082386, hamiltonian_energy_error = -0.18416566322605377, max_hamiltonian_energy_error = 3134.1486224573323, tree_depth = 2, numerical_error = true, step_size = 0.16176992779022556, nom_step_size = 0.16176992779022556, is_adapt = true), (n_steps = 7, is_accept = true, acceptance_rate = 0.5430743529867765, log_density = -98.369619480914, hamiltonian_energy = 224.73016600896628, hamiltonian_energy_error = -0.311756735084856, max_hamiltonian_energy_error = 3139.8821224977737, tree_depth = 2, numerical_error = true, step_size = 0.07321017286660231, nom_step_size = 0.07321017286660231, is_adapt = true), (n_steps = 11, is_accept = true, acceptance_rate = 0.3867565060637031, log_density = -85.08378657468218, hamiltonian_energy = 209.98411342596106, hamiltonian_energy_error = -3.3944248918689084, max_hamiltonian_energy_error = 1826.3720089176848, tree_depth = 3, numerical_error = true, step_size = 0.09243259300011354, nom_step_size = 0.09243259300011354, is_adapt = true), (n_steps = 12, is_accept = true, acceptance_rate = 0.6128158556963188, log_density = -97.6685930120681, hamiltonian_energy = 223.9424122333595, hamiltonian_energy_error = -2.4803188703084516, max_hamiltonian_energy_error = 1872.7630676766753, tree_depth = 3, numerical_error = true, step_size = 0.07381959954789134, nom_step_size = 0.07381959954789134, is_adapt = true), (n_steps = 11, is_accept = true, acceptance_rate = 0.0020560096431892767, log_density = -97.6685930120681, hamiltonian_energy = 211.96810293244476, hamiltonian_energy_error = 0.0, max_hamiltonian_energy_error = 2645.203538807581, tree_depth = 3, numerical_error = true, step_size = 0.12088479673335951, nom_step_size = 0.12088479673335951, is_adapt = true), (n_steps = 127, is_accept = true, acceptance_rate = 0.39067579607212544, log_density = -137.80082359079498, hamiltonian_energy = 214.1659450306297, hamiltonian_energy_error = -1.574295988764817, max_hamiltonian_energy_error = 117.2852311645938, tree_depth = 7, numerical_error = false, step_size = 0.029177915045582602, nom_step_size = 0.029177915045582602, is_adapt = true)  …  (n_steps = 95, is_accept = true, acceptance_rate = 0.0009643880277311219, log_density = -121.3537023434279, hamiltonian_energy = 290.92479302139225, hamiltonian_energy_error = 0.0, max_hamiltonian_energy_error = 2045.8793057998955, tree_depth = 6, numerical_error = true, step_size = 0.04292962634093491, nom_step_size = 0.04292962634093491, is_adapt = true), (n_steps = 255, is_accept = true, acceptance_rate = 0.8082214733022286, log_density = -113.17515366015753, hamiltonian_energy = 246.40015463119943, hamiltonian_energy_error = 0.13369062572604662, max_hamiltonian_energy_error = 1.0587154887178656, tree_depth = 8, numerical_error = false, step_size = 0.014093648755081277, nom_step_size = 0.014093648755081277, is_adapt = true), (n_steps = 127, is_accept = true, acceptance_rate = 0.32398153218070747, log_density = -119.713313177986, hamiltonian_energy = 219.94543621776631, hamiltonian_energy_error = -0.14667528099801075, max_hamiltonian_energy_error = 31.62102981454322, tree_depth = 7, numerical_error = false, step_size = 0.03517539138115957, nom_step_size = 0.03517539138115957, is_adapt = true), (n_steps = 127, is_accept = true, acceptance_rate = 0.912921057782059, log_density = -129.3596658812137, hamiltonian_energy = 249.49226824877488, hamiltonian_energy_error = -0.9434554751174744, max_hamiltonian_energy_error = -1.6775114809568663, tree_depth = 7, numerical_error = false, step_size = 0.026136820954240764, nom_step_size = 0.026136820954240764, is_adapt = true), (n_steps = 2, is_accept = true, acceptance_rate = 0.0, log_density = -129.3596658812137, hamiltonian_energy = 257.20375285831904, hamiltonian_energy_error = 0.0, max_hamiltonian_energy_error = 1715.3038272925046, tree_depth = 1, numerical_error = true, step_size = 0.082882058952104, nom_step_size = 0.082882058952104, is_adapt = true), (n_steps = 127, is_accept = true, acceptance_rate = 0.15303436040868423, log_density = -125.13464461493186, hamiltonian_energy = 249.74367707233057, hamiltonian_energy_error = 2.3011486080281998, max_hamiltonian_energy_error = 3.928293246189412, tree_depth = 7, numerical_error = false, step_size = 0.02788598662345205, nom_step_size = 0.02788598662345205, is_adapt = true), (n_steps = 255, is_accept = true, acceptance_rate = 0.6764462177642027, log_density = -128.07293239184955, hamiltonian_energy = 268.7243440302745, hamiltonian_energy_error = 1.1119027962028554, max_hamiltonian_energy_error = 1.2566663178067756, tree_depth = 8, numerical_error = false, step_size = 0.01380097343235681, nom_step_size = 0.01380097343235681, is_adapt = true), (n_steps = 127, is_accept = true, acceptance_rate = 0.6696795681274815, log_density = -151.84573474803645, hamiltonian_energy = 274.2172339849918, hamiltonian_energy_error = 0.29116959052527136, max_hamiltonian_energy_error = 1.633036454704154, tree_depth = 7, numerical_error = false, step_size = 0.024290355729219185, nom_step_size = 0.024290355729219185, is_adapt = true), (n_steps = 127, is_accept = true, acceptance_rate = 0.03533921854234314, log_density = -152.23728174130355, hamiltonian_energy = 272.1279463021302, hamiltonian_energy_error = -0.7370030515120334, max_hamiltonian_energy_error = 94.86318231875447, tree_depth = 7, numerical_error = false, step_size = 0.0417382692882309, nom_step_size = 0.0417382692882309, is_adapt = true), (n_steps = 255, is_accept = true, acceptance_rate = 0.8086951448090548, log_density = -140.67523669952507, hamiltonian_energy = 272.9582080344553, hamiltonian_energy_error = 0.039324954411085855, max_hamiltonian_energy_error = 1.6648480032047246, tree_depth = 8, numerical_error = false, step_size = 0.01580207851547773, nom_step_size = 0.01580207851547773, is_adapt = true)])</code></pre><h2 id="Step-5:-Plot-diagnostics"><a class="docs-heading-anchor" href="#Step-5:-Plot-diagnostics">Step 5: Plot diagnostics</a><a id="Step-5:-Plot-diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Plot-diagnostics" title="Permalink"></a></h2><p>Now let&#39;s make sure the fit is good. This can be done by looking at the chain mixing plot and the autocorrelation plot. First, let&#39;s create the chain mixing plot using the plot recipes from ????</p><pre><code class="language-julia hljs">samples = hcat(samples...)
samples_reduced = samples[1:5, :]
samples_reshape = reshape(samples_reduced, (500, 5, 1))
Chain_Spiral = Chains(samples_reshape)
plot(Chain_Spiral)</code></pre><img src="334db41e.svg" alt="Example block output"/><p>Now we check the autocorrelation plot:</p><pre><code class="language-julia hljs">autocorplot(Chain_Spiral)</code></pre><img src="e5664e30.svg" alt="Example block output"/><p>As another diagnostic, let&#39;s check the result on retrodicted data. To do this, we generate solutions of the Neural ODE on samples of the neural network parameters, and check the results of the predictions against the data. Let&#39;s start by looking at the time series:</p><pre><code class="language-julia hljs">pl = scatter(tsteps, ode_data[1, :], color = :red, label = &quot;Data: Var1&quot;, xlabel = &quot;t&quot;,
             title = &quot;Spiral Neural ODE&quot;)
scatter!(tsteps, ode_data[2, :], color = :blue, label = &quot;Data: Var2&quot;)
for k in 1:300
    resol = predict_neuralode(samples[:, 100:end][:, rand(1:400)])
    plot!(tsteps, resol[1, :], alpha = 0.04, color = :red, label = &quot;&quot;)
    plot!(tsteps, resol[2, :], alpha = 0.04, color = :blue, label = &quot;&quot;)
end

losses = map(x -&gt; loss_neuralode(x)[1], eachcol(samples))
idx = findmin(losses)[2]
prediction = predict_neuralode(samples[:, idx])
plot!(tsteps, prediction[1, :], color = :black, w = 2, label = &quot;&quot;)
plot!(tsteps, prediction[2, :], color = :black, w = 2, label = &quot;Best fit prediction&quot;,
      ylims = (-2.5, 3.5))</code></pre><img src="e1a8fa0a.svg" alt="Example block output"/><p>That showed the time series form. We can similarly do a phase-space plot:</p><pre><code class="language-julia hljs">pl = scatter(ode_data[1, :], ode_data[2, :], color = :red, label = &quot;Data&quot;, xlabel = &quot;Var1&quot;,
             ylabel = &quot;Var2&quot;, title = &quot;Spiral Neural ODE&quot;)
for k in 1:300
    resol = predict_neuralode(samples[:, 100:end][:, rand(1:400)])
    plot!(resol[1, :], resol[2, :], alpha = 0.04, color = :red, label = &quot;&quot;)
end
plot!(prediction[1, :], prediction[2, :], color = :black, w = 2,
      label = &quot;Best fit prediction&quot;, ylims = (-2.5, 3))</code></pre><img src="6fbf25f3.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../missing_physics/">« Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a><a class="docs-footer-nextpage" href="../blackhole/">Discovering the Relativistic Corrections to Binary Black Hole Dynamics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 27 May 2024 17:56">Monday 27 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
